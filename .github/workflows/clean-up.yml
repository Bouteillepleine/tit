name: üßπ Cache & Workflow Cleanup

on:
  workflow_dispatch:
    inputs:
      cleanup_type:
        description: 'Cleanup scope'
        required: true
        type: choice
        default: 'analyze_only'
        options:
          - cache_only
          - runs_only
          - full_cleanup
          - analyze_only
      
      device_filter:
        description: 'Device/Kernel filter (ALL, device code, or kernel version)'
        required: false
        type: choice
        default: 'ALL'
        options:
          - ALL
          - android15-6.6
          - android14-6.1
          - android14-5.15
          - android13-5.15
          - android13-5.10
          - android12-5.10
          - OP13-CPH
          - OP13-PJZ
          - OP13r
          - OP13S
          - OP13T
          - OP12
          - OP12r
          - OP11
          - OP11r
          - OP10pro
          - OP10t
          - OP-Nord-5
          - OP-NORD-4
          - OP-NORD-4-CE
          - OP-NORD-CE4-LITE
          - OP-ACE-5-PRO
          - OP-ACE-5
          - OP-ACE-3-PRO
          - OP-ACE-3V
          - OP-ACE-2-PRO
          - OP-ACE-2
          - OP-OPEN
          - OP-PAD-3
          - OP-PAD-2-PRO
          - OP-PAD-2
          - OP-PAD-PRO
      
      cache_pattern:
        description: 'Cache cleanup pattern'
        required: false
        type: choice
        default: 'ccache_stale'
        options:
          - all_caches
          - ccache_only
          - ccache_stale
          - apt_only
          - kernel_only
          - old_only
      
      cache_age_days:
        description: 'Delete caches older than (days)'
        required: false
        type: number
        default: 7
      
      dry_run:
        description: 'Dry run (preview only, no deletions)'
        required: false
        type: boolean
        default: true
      
      force_cleanup:
        description: 'Force cleanup (override protections)'
        required: false
        type: boolean
        default: false

permissions:
  actions: write
  contents: read

concurrency:
  group: cache-maintenance
  cancel-in-progress: false

jobs:
  analyze:
    name: üìä Analyze Cache Health
    runs-on: ubuntu-latest
    outputs:
      total_size: ${{ steps.analyze.outputs.total_size }}
      total_count: ${{ steps.analyze.outputs.total_count }}
      health_status: ${{ steps.analyze.outputs.health_status }}
      recommendation: ${{ steps.analyze.outputs.recommendation }}
      cache_data: ${{ steps.analyze.outputs.cache_data }}
      
    steps:
      - name: üîç Fetch and Analyze Caches
        id: analyze
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const MAX_SIZE_GB = 10;
            const MAX_SIZE_BYTES = MAX_SIZE_GB * 1024 * 1024 * 1024;
            
            // ‚úÖ UPDATED: Tolerant v3 regex that accepts both ccache-v3-* and ccache-suki-v3-*
            const CACHE_PATTERNS = {
              // v4 format: ccache-suki-v4-MODEL-OS-ANDROID-KERNEL-CLANG
              v4: /^ccache-suki-v4-([^-]+)-([^-]+)-([^-]+)-([^-]+)-([^-]+)$/,
              
              // ‚úÖ NEW: Tolerant v3 format that accepts both forms
              // Matches: ccache-v3-* AND ccache-suki-v3-*
              // Groups: (1) android, (2) kernel, (3) device
              v3: /^ccache-(?:suki-)?v3-([^-]+)-([0-9.]+)-(?:[A-Za-z0-9.-]+-)?(?:clang-[A-Za-z0-9.-]+-)?([A-Za-z0-9._-]+)(?:-.+)?$/,
              
              // Legacy formats
              legacy1: /^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/,
              legacy2: /^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/,
              legacy3: /ccache-[^-]+-[^-]+-[^-]+-[^-]+-([^-]+)/
            };
            
            // ‚úÖ NEW: Safe number formatting helpers
            const toGB = bytes => bytes / 1024 / 1024 / 1024;
            const fmtGB = (bytes, countHint = 0) => {
              if (bytes === 0 && countHint > 0) return '0.00'; // brand-new cache
              const g = toGB(bytes);
              return g > 0 && g < 0.01 ? '<0.01' : g.toFixed(2);
            };
            const pct = (part, total) => total > 0 ? ((part / total) * 100).toFixed(1) + '%' : '0.0%';
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('Fetching repository caches...');
            const caches = await github.paginate(
              github.rest.actions.getActionsCacheList,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              }
            );
            
            console.log(`Found ${caches.length} total caches`);
            
            // Initialize statistics
            const stats = {
              totalSize: 0,
              totalCount: caches.length,
              cachesByType: {
                ccache: { size: 0, count: 0 },
                apt: { size: 0, count: 0 },
                kernel: { size: 0, count: 0 },
                other: { size: 0, count: 0 }
              },
              cacheKeyVersions: {
                v4: 0,
                v3: 0,
                legacy: 0
              },
              cachesByDevice: new Map(),
              ageDistribution: {
                fresh: 0,      // < 7 days
                recent: 0,     // 7-14 days
                old: 0,        // 14-30 days
                stale: 0       // > 30 days
              },
              activityDistribution: {
                active: 0,     // < 7 days
                recent: 0,     // 7-14 days
                dormant: 0,    // 14-30 days
                stale: 0       // > 30 days
              },
              oldestCache: null,
              newestCache: null
            };
            
            const now = new Date();
            const msPerDay = 24 * 60 * 60 * 1000;
            
            // Process each cache
            for (const cache of caches) {
              stats.totalSize += cache.size_in_bytes;
              
              const cacheDate = new Date(cache.created_at);
              const lastAccessDate = new Date(cache.last_accessed_at);
              const ageInDays = (now - cacheDate) / msPerDay;
              const daysSinceAccess = (now - lastAccessDate) / msPerDay;
              
              // Track oldest/newest
              if (!stats.oldestCache || cacheDate < new Date(stats.oldestCache.created_at)) {
                stats.oldestCache = cache;
              }
              if (!stats.newestCache || cacheDate > new Date(stats.newestCache.created_at)) {
                stats.newestCache = cache;
              }
              
              // Age distribution
              if (ageInDays < 7) stats.ageDistribution.fresh++;
              else if (ageInDays < 14) stats.ageDistribution.recent++;
              else if (ageInDays < 30) stats.ageDistribution.old++;
              else stats.ageDistribution.stale++;
              
              // Activity distribution
              if (daysSinceAccess < 7) stats.activityDistribution.active++;
              else if (daysSinceAccess < 14) stats.activityDistribution.recent++;
              else if (daysSinceAccess < 30) stats.activityDistribution.dormant++;
              else stats.activityDistribution.stale++;
              
              // Categorize by type
              if (cache.key.startsWith('ccache-')) {
                stats.cachesByType.ccache.size += cache.size_in_bytes;
                stats.cachesByType.ccache.count++;
                
                // ‚úÖ UPDATED: Parse cache key format with tolerant v3 regex
                let device = null;
                let osVersion = null;
                let androidVer = null;
                let kernelVer = null;
                let isV4 = false;
                let isV3 = false;
                
                // Try v4 format first
                const v4Match = cache.key.match(CACHE_PATTERNS.v4);
                if (v4Match) {
                  stats.cacheKeyVersions.v4++;
                  isV4 = true;
                  device = v4Match[1];        // OP13
                  osVersion = v4Match[2];     // OOS15
                  androidVer = v4Match[3];    // android14
                  kernelVer = v4Match[4];     // 6.1
                  // clangVer = v4Match[5];   // r510928
                } 
                // ‚úÖ UPDATED: Try tolerant v3 format (accepts both ccache-v3-* and ccache-suki-v3-*)
                else {
                  const v3Match = cache.key.match(CACHE_PATTERNS.v3);
                  if (v3Match) {
                    stats.cacheKeyVersions.v3++;
                    isV3 = true;
                    androidVer = v3Match[1];  // android14
                    kernelVer = v3Match[2];   // 6.1
                    device = v3Match[3];      // OP-ACE-5 or OP-ACE-3V
                  }
                  // Try legacy formats
                  else {
                    stats.cacheKeyVersions.legacy++;
                    const legacy1 = cache.key.match(CACHE_PATTERNS.legacy1);
                    const legacy2 = cache.key.match(CACHE_PATTERNS.legacy2);
                    const legacy3 = cache.key.match(CACHE_PATTERNS.legacy3);
                    device = legacy1?.[1] || legacy2?.[1] || legacy3?.[1] || null;
                  }
                }
                
                // Track by device
                if (device) {
                  if (!stats.cachesByDevice.has(device)) {
                    stats.cachesByDevice.set(device, {
                      size: 0,
                      count: 0,
                      lastAccessed: lastAccessDate,
                      oldestCache: cacheDate,
                      newestCache: cacheDate,
                      oldestAccess: lastAccessDate,
                      newestAccess: lastAccessDate,
                      osVersions: new Set(),
                      androidVersions: new Set(),
                      kernelVersions: new Set(),
                      v4Count: 0,
                      v3Count: 0,
                      legacyCount: 0
                    });
                  }
                  
                  const deviceData = stats.cachesByDevice.get(device);
                  deviceData.size += cache.size_in_bytes;
                  deviceData.count++;
                  
                  // Track format versions
                  if (isV4) deviceData.v4Count++;
                  else if (isV3) deviceData.v3Count++;
                  else deviceData.legacyCount++;
                  
                  // Track versions
                  if (osVersion) deviceData.osVersions.add(osVersion);
                  if (androidVer) deviceData.androidVersions.add(androidVer);
                  if (kernelVer) deviceData.kernelVersions.add(kernelVer);
                  
                  // Update timestamps
                  if (lastAccessDate > deviceData.lastAccessed) {
                    deviceData.lastAccessed = lastAccessDate;
                  }
                  if (cacheDate < deviceData.oldestCache) {
                    deviceData.oldestCache = cacheDate;
                  }
                  if (cacheDate > deviceData.newestCache) {
                    deviceData.newestCache = cacheDate;
                  }
                  if (lastAccessDate < deviceData.oldestAccess) {
                    deviceData.oldestAccess = lastAccessDate;
                  }
                  if (lastAccessDate > deviceData.newestAccess) {
                    deviceData.newestAccess = lastAccessDate;
                  }
                }
              } 
              else if (cache.key.includes('apt-')) {
                stats.cachesByType.apt.size += cache.size_in_bytes;
                stats.cachesByType.apt.count++;
              } 
              else if (cache.key.includes('kernel-source')) {
                stats.cachesByType.kernel.size += cache.size_in_bytes;
                stats.cachesByType.kernel.count++;
              } 
              else {
                stats.cachesByType.other.size += cache.size_in_bytes;
                stats.cachesByType.other.count++;
              }
            }
            
            // ‚úÖ UPDATED: Safe usage percent calculation
            const usagePercent = stats.totalSize > 0 ? (stats.totalSize / MAX_SIZE_BYTES) * 100 : 0;
            const usagePercentStr = usagePercent.toFixed(1);
            
            let healthStatus = 'Healthy';
            let recommendation = '‚úÖ No action needed';
            
            if (usagePercent > 90) {
              healthStatus = 'Critical';
              recommendation = 'üö® Immediate cleanup required';
            } else if (usagePercent > 75) {
              healthStatus = 'Warning';
              recommendation = '‚ö†Ô∏è Consider cleanup soon';
            } else if (usagePercent > 50) {
              healthStatus = 'Caution';
              recommendation = 'üí° Monitor usage';
            }
            
            // Convert Map to Array for JSON serialization
            const deviceArray = Array.from(stats.cachesByDevice.entries()).map(([device, data]) => ({
              device,
              size: data.size,
              count: data.count,
              lastAccessed: data.lastAccessed.toISOString(),
              oldestCache: data.oldestCache.toISOString(),
              newestCache: data.newestCache.toISOString(),
              osVersions: Array.from(data.osVersions),
              androidVersions: Array.from(data.androidVersions),
              kernelVersions: Array.from(data.kernelVersions),
              v4Count: data.v4Count,
              v3Count: data.v3Count,
              legacyCount: data.legacyCount
            })).sort((a, b) => b.size - a.size);
            
            // ‚úÖ UPDATED: Use safe formatting helpers
            const totalSizeGB = fmtGB(stats.totalSize, stats.totalCount);
            
            let healthEmoji = 'üü¢';
            if (usagePercent > 90) healthEmoji = 'üî¥';
            else if (usagePercent > 75) healthEmoji = 'üü°';
            
            const summary = core.summary
              .addHeading(`${healthEmoji} Repository Cache Health Report`, 2)
              .addRaw(`\n**Analysis Date:** ${new Date().toISOString()}\n\n`);
            
            summary.addHeading('üìä Overall Statistics', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}, {data: 'Status', header: true}],
                ['Total Cache Size', `${totalSizeGB} GB`, `${usagePercentStr}% of ${MAX_SIZE_GB} GB`],
                ['Total Cache Count', stats.totalCount.toString(), healthEmoji],
                ['Health Status', healthStatus, healthEmoji],
                ['Recommendation', recommendation, '']
              ]);
            
            // ‚úÖ UPDATED: Use safe formatting for cache breakdown
            summary.addHeading('üóÇÔ∏è Cache Breakdown by Type', 3)
              .addTable([
                [{data: 'Type', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, {data: 'Percentage', header: true}],
                ['ccache', 
                 stats.cachesByType.ccache.count.toString(),
                 fmtGB(stats.cachesByType.ccache.size, stats.cachesByType.ccache.count),
                 pct(stats.cachesByType.ccache.size, stats.totalSize)],
                ['apt packages',
                 stats.cachesByType.apt.count.toString(),
                 fmtGB(stats.cachesByType.apt.size, stats.cachesByType.apt.count),
                 pct(stats.cachesByType.apt.size, stats.totalSize)],
                ['kernel sources',
                 stats.cachesByType.kernel.count.toString(),
                 fmtGB(stats.cachesByType.kernel.size, stats.cachesByType.kernel.count),
                 pct(stats.cachesByType.kernel.size, stats.totalSize)],
                ['other',
                 stats.cachesByType.other.count.toString(),
                 fmtGB(stats.cachesByType.other.size, stats.cachesByType.other.count),
                 pct(stats.cachesByType.other.size, stats.totalSize)]
              ]);
            
            // ‚úÖ UPDATED: Clarified v3 label to show both forms accepted
            const totalVersionedCaches = stats.cacheKeyVersions.v4 + stats.cacheKeyVersions.v3 + stats.cacheKeyVersions.legacy;
            summary.addHeading('üîë Cache Key Versions', 3)
              .addTable([
                [{data: 'Format', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['v4 (ccache-suki-v4-*)', 
                 stats.cacheKeyVersions.v4.toString(),
                 totalVersionedCaches > 0 ? pct(stats.cacheKeyVersions.v4, totalVersionedCaches) : '0.0%'],
                ['v3 (ccache[-suki]-v3-*)', 
                 stats.cacheKeyVersions.v3.toString(),
                 totalVersionedCaches > 0 ? pct(stats.cacheKeyVersions.v3, totalVersionedCaches) : '0.0%'],
                ['Legacy (old format)',
                 stats.cacheKeyVersions.legacy.toString(),
                 totalVersionedCaches > 0 ? pct(stats.cacheKeyVersions.legacy, totalVersionedCaches) : '0.0%']
              ]);
            
            if (stats.cacheKeyVersions.v4 === totalVersionedCaches && totalVersionedCaches > 0) {
              summary.addRaw(`\n‚úÖ **All caches using v4 format**\n\n`);
            } else {
              if (stats.cacheKeyVersions.v3 > 0) {
                summary.addRaw(`\n> ‚ÑπÔ∏è **v3 Caches Detected**: ${stats.cacheKeyVersions.v3} caches use v3 format (both ccache-v3-* and ccache-suki-v3-*). Consider migration to v4.\n\n`);
              }
              if (stats.cacheKeyVersions.legacy > 0) {
                summary.addRaw(`\n> ‚ö†Ô∏è **Legacy Caches Detected**: ${stats.cacheKeyVersions.legacy} caches use old format. Migration to v4 recommended.\n\n`);
              }
            }
            
            summary.addHeading('üìÖ Cache Age Distribution (by creation date)', 3)
              .addTable([
                [{data: 'Age Range', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['< 7 days (Fresh)', stats.ageDistribution.fresh.toString(), pct(stats.ageDistribution.fresh, stats.totalCount)],
                ['7-14 days (Recent)', stats.ageDistribution.recent.toString(), pct(stats.ageDistribution.recent, stats.totalCount)],
                ['14-30 days (Old)', stats.ageDistribution.old.toString(), pct(stats.ageDistribution.old, stats.totalCount)],
                ['> 30 days (Stale)', stats.ageDistribution.stale.toString(), pct(stats.ageDistribution.stale, stats.totalCount)]
              ]);
            
            summary.addHeading('üîÑ Activity Distribution (by last access)', 3)
              .addTable([
                [{data: 'Activity Level', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['< 7 days (Active)', stats.activityDistribution.active.toString(), pct(stats.activityDistribution.active, stats.totalCount)],
                ['7-14 days (Recent)', stats.activityDistribution.recent.toString(), pct(stats.activityDistribution.recent, stats.totalCount)],
                ['14-30 days (Dormant)', stats.activityDistribution.dormant.toString(), pct(stats.activityDistribution.dormant, stats.totalCount)],
                ['> 30 days (Stale)', stats.activityDistribution.stale.toString(), pct(stats.activityDistribution.stale, stats.totalCount)]
              ]);
            
            // Device breakdown
            if (deviceArray.length > 0) {
              const inactiveDevices = deviceArray.filter(d => {
                const daysSinceAccess = (now - new Date(d.lastAccessed)) / msPerDay;
                return daysSinceAccess > 30;
              });
              
              summary.addHeading('üì± Top 15 Devices by Cache Size', 3)
                .addTable([
                  [{data: 'Device', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, 
                   {data: 'v4/v3/Legacy', header: true}, {data: 'Last Access', header: true}, {data: 'OS Versions', header: true}],
                  ...deviceArray.slice(0, 15).map(d => [
                    d.device,
                    d.count.toString(),
                    fmtGB(d.size, d.count),
                    `${d.v4Count}/${d.v3Count}/${d.legacyCount}`,
                    `${Math.floor((now - new Date(d.lastAccessed)) / msPerDay)}d ago`,
                    d.osVersions.join(', ') || 'N/A'
                  ])
                ]);
              
              if (inactiveDevices.length > 0) {
                summary.addHeading('‚ö†Ô∏è Inactive Devices (>30 days since last access)', 3)
                  .addTable([
                    [{data: 'Device', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, 
                     {data: 'Last Access', header: true}, {data: 'Potential Savings', header: true}],
                    ...inactiveDevices.slice(0, 10).map(d => [
                      d.device,
                      d.count.toString(),
                      fmtGB(d.size, d.count),
                      `${Math.floor((now - new Date(d.lastAccessed)) / msPerDay)}d ago`,
                      pct(d.size, stats.totalSize)
                    ])
                  ]);
                
                const potentialSavings = inactiveDevices.reduce((sum, d) => sum + d.size, 0);
                const savingsGB = fmtGB(potentialSavings);
                summary.addRaw(`\n> üí° **Potential Savings**: Cleaning inactive devices could free up **${savingsGB} GB** (${pct(potentialSavings, stats.totalSize)} of total)\n\n`);
              }
            }
            
            // Recommendations
            summary.addHeading('üí° Recommendations', 3);
            
            if (usagePercent > 90) {
              summary.addRaw(`\n‚ö†Ô∏è **Action Required**: Cache usage is critical (${usagePercentStr}%). Immediate cleanup recommended.\n\n`);
            } else if (usagePercent > 75) {
              summary.addRaw(`\n‚ö†Ô∏è **Warning**: Cache usage is high (${usagePercentStr}%). Consider cleanup soon.\n\n`);
            } else {
              summary.addRaw(`\n‚úÖ **Healthy**: Cache usage is normal (${usagePercentStr}%). No immediate action needed.\n\n`);
            }
            
            if (stats.cacheKeyVersions.v3 > 0) {
              summary.addRaw(`- üîÑ **v3 Migration**: ${stats.cacheKeyVersions.v3} v3 caches detected. Consider migrating to v4 format.\n`);
            }
            if (stats.cacheKeyVersions.legacy > 0) {
              summary.addRaw(`- üîÑ **Legacy Migration**: ${stats.cacheKeyVersions.legacy} legacy caches detected. Run migration cleanup.\n`);
            }
            if (stats.activityDistribution.stale > 0) {
              summary.addRaw(`- üßπ **Stale Caches**: ${stats.activityDistribution.stale} caches haven't been accessed in 30+ days.\n`);
            }
            
            await summary.write();
            
            // Set outputs
            core.setOutput('total_size', totalSizeGB);
            core.setOutput('total_count', stats.totalCount);
            core.setOutput('health_status', healthStatus);
            core.setOutput('recommendation', recommendation);
            core.setOutput('cache_data', JSON.stringify({
              totalSize: stats.totalSize,
              totalCount: stats.totalCount,
              usagePercent: usagePercentStr,
              maxSizeGB: MAX_SIZE_GB,
              cachesByType: stats.cachesByType,
              cacheKeyVersions: stats.cacheKeyVersions,
              cachesByDevice: deviceArray,
              ageDistribution: stats.ageDistribution,
              activityDistribution: stats.activityDistribution,
              oldestCache: stats.oldestCache,
              newestCache: stats.newestCache,
              healthStatus,
              recommendation
            }));
            
            console.log('Analysis complete');
            console.log(`Total size: ${totalSizeGB} GB`);
            console.log(`Usage: ${usagePercentStr}%`);
            console.log(`Health: ${healthStatus}`);

  cleanup-caches:
    name: üßπ Cleanup Caches
    runs-on: ubuntu-latest
    needs: analyze
    if: |
      inputs.cleanup_type == 'cache_only' || 
      inputs.cleanup_type == 'full_cleanup'
    
    steps:
      - name: üóëÔ∏è Delete Matching Caches
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const deviceFilter = '${{ inputs.device_filter }}';
            const cachePattern = '${{ inputs.cache_pattern }}';
            const cacheAgeDays = parseInt('${{ inputs.cache_age_days }}');
            const forceCleanup = '${{ inputs.force_cleanup }}' === 'true';
            
            // ‚úÖ UPDATED: Tolerant v3 regex
            const V4_PATTERN = /^ccache-suki-v4-([^-]+)-([^-]+)-([^-]+)-([^-]+)-([^-]+)$/;
            const V3_PATTERN = /^ccache-(?:suki-)?v3-([^-]+)-([0-9.]+)-(?:[A-Za-z0-9.-]+-)?(?:clang-[A-Za-z0-9.-]+-)?([A-Za-z0-9._-]+)(?:-.+)?$/;
            
            // ‚úÖ NEW: Safe number formatting helpers
            const toGB = bytes => bytes / 1024 / 1024 / 1024;
            const fmtGB = (bytes, countHint = 0) => {
              if (bytes === 0 && countHint > 0) return '0.00';
              const g = toGB(bytes);
              return g > 0 && g < 0.01 ? '<0.01' : g.toFixed(2);
            };
            const pct = (part, total) => total > 0 ? ((part / total) * 100).toFixed(1) + '%' : '0.0%';
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('üßπ Starting cache cleanup...\n');
            console.log(`Configuration:`);
            console.log(`  Device Filter: ${deviceFilter}`);
            console.log(`  Cache Pattern: ${cachePattern}`);
            console.log(`  Age Threshold: ${cacheAgeDays} days`);
            console.log(`  Dry Run: ${dryRun}`);
            console.log(`  Force Cleanup: ${forceCleanup}\n`);
            
            const staleCutoffDate = new Date(Date.now() - cacheAgeDays * 24 * 60 * 60 * 1000);
            const veryStaleCutoffDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const veryRecentCutoffDate = new Date(Date.now() - 2 * 60 * 60 * 1000);
            
            let totalDeleted = 0;
            let totalFreed = 0;
            const deletedCaches = [];
            const failedDeletions = [];
            const deletedDevices = new Set();
            
            const deletionStats = {
              ccache: { count: 0, size: 0, v4: 0, v3: 0, legacy: 0 },
              apt: { count: 0, size: 0 },
              kernel: { count: 0, size: 0 },
              other: { count: 0, size: 0 }
            };
            
            function shouldDeleteCache(cache) {
              const cacheKey = cache.key;
              const cacheDate = new Date(cache.created_at);
              const lastAccessDate = new Date(cache.last_accessed_at || cache.created_at);
              const accessAgeDays = Math.floor((new Date() - lastAccessDate) / (1000 * 60 * 60 * 24));
              
              const isV4Format = cacheKey.startsWith('ccache-suki-v4-');
              const isV3Format = cacheKey.startsWith('ccache-v3-') || cacheKey.startsWith('ccache-suki-v3-');
              
              // Protection: Don't delete very recently used caches
              if (lastAccessDate > veryRecentCutoffDate && !forceCleanup) {
                return { delete: false, reason: 'recently_used', accessAgeDays: Math.floor((new Date() - lastAccessDate) / (1000 * 60 * 60)) };
              }
              
              let device = null;
              let kernel = null;
              
              // ‚úÖ UPDATED: Parse with tolerant v3 regex
              if (isV4Format) {
                const v4Match = cacheKey.match(V4_PATTERN);
                if (v4Match) {
                  device = v4Match[1];        // OP13
                  kernel = v4Match[4];        // 6.1
                }
              } else if (isV3Format) {
                const v3Match = cacheKey.match(V3_PATTERN);
                if (v3Match) {
                  // androidVer = v3Match[1]; // android14
                  kernel = v3Match[2];        // 6.1
                  device = v3Match[3];        // OP-ACE-5 or OP-ACE-3V
                }
              } else if (cacheKey.startsWith('ccache-')) {
                // Legacy format
                const legacy1 = cacheKey.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                const legacy2 = cacheKey.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                device = legacy1?.[1] || legacy2?.[1] || null;
              }
              
              // Device filter matching
              const exactMatch =
                deviceFilter === 'ALL' ||
                (device && deviceFilter.toLowerCase() === device.toLowerCase()) ||
                (kernel && deviceFilter.toLowerCase() === kernel.toLowerCase());
              
              const looseMatch =
                cacheKey.includes(`-${deviceFilter}-`) ||
                cacheKey.endsWith(`-${deviceFilter}`) ||
                cacheKey.startsWith(`${deviceFilter}-`);
              
              const deviceMatchesFilter = exactMatch || looseMatch;
              
              if (!deviceMatchesFilter) {
                return { delete: false, reason: 'device_filter' };
              }
              
              let patternMatch = false;
              let category = 'other';
              
              switch (cachePattern) {
                case 'all_caches':
                  patternMatch = true;
                  category = cacheKey.startsWith('ccache-') ? 'ccache' :
                            cacheKey.startsWith('apt-') ? 'apt' :
                            (cacheKey.includes('kernel') || cacheKey.includes('linux-')) ? 'kernel' : 'other';
                  break;
                
                case 'ccache_only':
                  if (cacheKey.startsWith('ccache-')) {
                    patternMatch = true;
                    category = 'ccache';
                  }
                  break;
                
                case 'ccache_stale':
                  if (cacheKey.startsWith('ccache-') && lastAccessDate < staleCutoffDate) {
                    patternMatch = true;
                    category = 'ccache';
                  }
                  break;
                
                case 'apt_only':
                  if (cacheKey.startsWith('apt-')) {
                    patternMatch = true;
                    category = 'apt';
                  }
                  break;
                
                case 'kernel_only':
                  if (cacheKey.includes('kernel') || cacheKey.includes('linux-')) {
                    patternMatch = true;
                    category = 'kernel';
                  }
                  break;
                
                case 'old_only':
                  if (cacheDate < staleCutoffDate) {
                    patternMatch = true;
                    category = cacheKey.startsWith('ccache-') ? 'ccache' :
                              cacheKey.startsWith('apt-') ? 'apt' :
                              (cacheKey.includes('kernel') || cacheKey.includes('linux-')) ? 'kernel' : 'other';
                  }
                  break;
              }
              
              return { 
                delete: patternMatch, 
                reason: patternMatch ? 'match' : 'pattern_mismatch',
                category: category,
                device: device,
                isV4: isV4Format,
                isV3: isV3Format,
                accessAgeDays: accessAgeDays
              };
            }
            
            // Fetch and process caches
            console.log('üîç Scanning caches...\n');
            
            const caches = await github.paginate(
              github.rest.actions.getActionsCacheList,
              {
                owner,
                repo,
                per_page: 100
              }
            );
            
            for (const cache of caches) {
              const decision = shouldDeleteCache(cache);
              const sizeMB = (cache.size_in_bytes / 1024 / 1024).toFixed(2);
              const agedays = Math.floor((new Date() - new Date(cache.created_at)) / (1000 * 60 * 60 * 24));
              
              if (decision.delete) {
                deletedCaches.push({
                  key: cache.key,
                  size: sizeMB,
                  sizeBytes: cache.size_in_bytes,
                  age: agedays,
                  created: cache.created_at,
                  accessed: cache.last_accessed_at || cache.created_at,
                  id: cache.id,
                  category: decision.category,
                  device: decision.device,
                  accessAgeDays: decision.accessAgeDays
                });
                
                if (decision.device) {
                  deletedDevices.add(decision.device);
                }
                
                if (dryRun) {
                  console.log(`üîç Would delete: ${cache.key}`);
                  console.log(`   Size: ${sizeMB} MB | Age: ${agedays} days | Type: ${decision.category}`);
                } else {
                  console.log(`üóëÔ∏è Deleting: ${cache.key}`);
                  console.log(`   Size: ${sizeMB} MB | Age: ${agedays} days | Type: ${decision.category}`);
                  
                  try {
                    await withRetry(() =>
                      github.rest.actions.deleteActionsCacheById({
                        owner,
                        repo,
                        cache_id: cache.id
                      })
                    );
                    totalDeleted++;
                    totalFreed += cache.size_in_bytes;
                    
                    // Update category stats
                    deletionStats[decision.category].count++;
                    deletionStats[decision.category].size += cache.size_in_bytes;
                    
                    // Track format versions for ccache
                    if (decision.category === 'ccache') {
                      if (decision.isV4) deletionStats.ccache.v4++;
                      else if (decision.isV3) deletionStats.ccache.v3++;
                      else deletionStats.ccache.legacy++;
                    }
                  } catch (error) {
                    console.log(`   ‚ö†Ô∏è Failed: ${error.message}`);
                    failedDeletions.push({
                      key: cache.key,
                      error: error.message
                    });
                  }
                }
              }
            }
            
            // ‚úÖ UPDATED: Use safe formatting
            const freedGB = fmtGB(totalFreed, totalDeleted);
            
            console.log(`\n‚úÖ Cleanup ${dryRun ? 'simulation' : 'complete'}:`);
            console.log(`   ${dryRun ? 'Would delete' : 'Deleted'}: ${totalDeleted} caches`);
            console.log(`   ${dryRun ? 'Would free' : 'Freed'}: ${freedGB} GB\n`);
            
            // Generate summary
            const summary = core.summary
              .addHeading(`üßπ Cache Cleanup ${dryRun ? 'Preview' : 'Report'}`, 2)
              .addRaw(`\n**Cleanup Date:** ${new Date().toISOString()}\n\n`);
            
            if (dryRun) {
              summary.addRaw(`> ‚ö†Ô∏è **DRY RUN MODE** - No caches were actually deleted. This is a preview of what would be deleted.\n\n`);
            }
            
            summary.addHeading('üìä Cleanup Summary', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Caches ' + (dryRun ? 'to Delete' : 'Deleted'), totalDeleted.toString()],
                ['Space ' + (dryRun ? 'to Free' : 'Freed'), `${freedGB} GB`],
                ['Device Filter', deviceFilter],
                ['Cache Pattern', cachePattern],
                ['Age Threshold', `${cacheAgeDays} days`],
                ['Force Cleanup', forceCleanup ? 'Yes' : 'No']
              ]);
            
            // ‚úÖ UPDATED: Use safe formatting
            summary.addHeading('üóÇÔ∏è Deletion Breakdown by Type', 3)
              .addTable([
                [{data: 'Type', header: true}, {data: 'Count', header: true}, {data: 'Size (GB)', header: true}, {data: 'Percentage', header: true}],
                ['ccache',
                 deletionStats.ccache.count.toString(),
                 fmtGB(deletionStats.ccache.size, deletionStats.ccache.count),
                 pct(deletionStats.ccache.size, totalFreed)],
                ['apt packages',
                 deletionStats.apt.count.toString(),
                 fmtGB(deletionStats.apt.size, deletionStats.apt.count),
                 pct(deletionStats.apt.size, totalFreed)],
                ['kernel sources',
                 deletionStats.kernel.count.toString(),
                 fmtGB(deletionStats.kernel.size, deletionStats.kernel.count),
                 pct(deletionStats.kernel.size, totalFreed)],
                ['other',
                 deletionStats.other.count.toString(),
                 fmtGB(deletionStats.other.size, deletionStats.other.count),
                 pct(deletionStats.other.size, totalFreed)]
              ]);
            
            if (deletionStats.ccache.count > 0) {
              summary.addHeading('üîë ccache Format Breakdown', 3)
                .addTable([
                  [{data: 'Format', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                  ['v4 format', 
                   deletionStats.ccache.v4.toString(),
                   pct(deletionStats.ccache.v4, deletionStats.ccache.count)],
                  ['v3 format', 
                   deletionStats.ccache.v3.toString(),
                   pct(deletionStats.ccache.v3, deletionStats.ccache.count)],
                  ['Legacy format',
                   deletionStats.ccache.legacy.toString(),
                   pct(deletionStats.ccache.legacy, deletionStats.ccache.count)]
                ]);
            }
            
            if (deletedCaches.length > 0) {
              const largestDeleted = deletedCaches
                .sort((a, b) => b.sizeBytes - a.sizeBytes)
                .slice(0, 20);
              
              summary.addHeading('üì¶ Top 20 Largest Caches ' + (dryRun ? 'to Delete' : 'Deleted'), 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Size (MB)', header: true}, 
                   {data: 'Category', header: true}, {data: 'Last Access', header: true}],
                  ...largestDeleted.map(cache => [
                    cache.key,
                    cache.size,
                    cache.category,
                    `${cache.accessAgeDays}d ago`
                  ])
                ]);
            }
            
            if (failedDeletions.length > 0) {
              summary.addHeading('‚ùå Failed Deletions', 3)
                .addTable([
                  [{data: 'Cache Key', header: true}, {data: 'Error', header: true}],
                  ...failedDeletions.map(f => [f.key, f.error])
                ]);
            }
            
            await summary.write();

  cleanup-runs:
    name: üóëÔ∏è Cleanup Workflow Runs
    runs-on: ubuntu-latest
    needs: analyze
    if: |
      inputs.cleanup_type == 'runs_only' || 
      inputs.cleanup_type == 'full_cleanup'
    
    steps:
      - name: üßπ Delete Old Runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const keepDays = 30;
            const keepRecent = 5;
            
            // ‚úÖ NEW: Safe percentage helper
            const pct = (part, total) => total > 0 ? ((part / total) * 100).toFixed(1) + '%' : '0.0%';
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('üóëÔ∏è Starting workflow runs cleanup...\n');
            console.log(`Configuration:`);
            console.log(`  Keep Days: ${keepDays}`);
            console.log(`  Keep Recent Successful: ${keepRecent}`);
            console.log(`  Dry Run: ${dryRun}\n`);
            
            const cutoffDate = new Date(Date.now() - keepDays * 24 * 60 * 60 * 1000);
            
            let totalDeleted = 0;
            const deletionsByWorkflow = new Map();
            const deletionsByStatus = {
              failed: 0,
              cancelled: 0,
              skipped: 0,
              success: 0
            };
            
            const workflows = await withRetry(() =>
              github.rest.actions.listRepoWorkflows({
                owner,
                repo
              })
            );
            
            for (const workflow of workflows.data.workflows) {
              console.log(`\nüìã Processing workflow: ${workflow.name}`);
              
              const successfulRuns = [];
              
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRuns,
                {
                  owner,
                  repo,
                  workflow_id: workflow.id,
                  per_page: 100
                }
              );
              
              for (const run of runs) {
                const runDate = new Date(run.created_at);
                const isOld = runDate < cutoffDate;
                
                const isFailed = run.conclusion === 'failure';
                const isCancelled = run.conclusion === 'cancelled';
                const isSkipped = run.conclusion === 'skipped';
                
                if (run.conclusion === 'success') {
                  successfulRuns.push(run);
                }
                
                const tooManySuccessful = run.conclusion === 'success' && 
                                         isOld &&
                                         successfulRuns.length > keepRecent;
                
                const shouldDelete = 
                  (isFailed && isOld) ||
                  (isCancelled && isOld) ||
                  (isSkipped && isOld) ||
                  tooManySuccessful;
                
                if (shouldDelete) {
                  console.log(`${dryRun ? '[DRY RUN] Would delete' : 'Deleting'}: Run #${run.run_number} (${run.conclusion}, ${Math.floor((new Date() - runDate) / (1000 * 60 * 60 * 24))}d old)`);
                  
                  if (!dryRun) {
                    try {
                      await withRetry(() =>
                        github.rest.actions.deleteWorkflowRun({
                          owner,
                          repo,
                          run_id: run.id
                        })
                      );
                    } catch (error) {
                      console.error(`‚ùå Failed to delete run #${run.run_number}: ${error.message}`);
                      continue;
                    }
                  }
                  
                  totalDeleted++;
                  
                  if (!deletionsByWorkflow.has(workflow.name)) {
                    deletionsByWorkflow.set(workflow.name, 0);
                  }
                  deletionsByWorkflow.set(workflow.name, deletionsByWorkflow.get(workflow.name) + 1);
                  
                  if (isFailed) deletionsByStatus.failed++;
                  else if (isCancelled) deletionsByStatus.cancelled++;
                  else if (isSkipped) deletionsByStatus.skipped++;
                  else if (run.conclusion === 'success') deletionsByStatus.success++;
                }
              }
            }
            
            console.log(`\n‚úÖ Runs cleanup ${dryRun ? 'simulation' : 'complete'}:`);
            console.log(`   ${dryRun ? 'Would delete' : 'Deleted'}: ${totalDeleted} runs\n`);
            
            const summary = core.summary
              .addHeading(`üóëÔ∏è Workflow Runs Cleanup ${dryRun ? 'Preview' : 'Report'}`, 2)
              .addRaw(`\n**Cleanup Date:** ${new Date().toISOString()}\n\n`);
            
            if (dryRun) {
              summary.addRaw(`> ‚ö†Ô∏è **DRY RUN MODE** - No runs were actually deleted. This is a preview.\n\n`);
            }
            
            summary.addHeading('üìä Cleanup Summary', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['Runs ' + (dryRun ? 'to Delete' : 'Deleted'), totalDeleted.toString()],
                ['Keep Days', `${keepDays} days`],
                ['Keep Recent Successful', `${keepRecent} per workflow`]
              ]);
            
            // ‚úÖ UPDATED: Use safe percentage helper
            summary.addHeading('üìà Deletions by Status', 3)
              .addTable([
                [{data: 'Status', header: true}, {data: 'Count', header: true}, {data: 'Percentage', header: true}],
                ['Failed', deletionsByStatus.failed.toString(), pct(deletionsByStatus.failed, totalDeleted)],
                ['Cancelled', deletionsByStatus.cancelled.toString(), pct(deletionsByStatus.cancelled, totalDeleted)],
                ['Skipped', deletionsByStatus.skipped.toString(), pct(deletionsByStatus.skipped, totalDeleted)],
                ['Success (old)', deletionsByStatus.success.toString(), pct(deletionsByStatus.success, totalDeleted)]
              ]);
            
            if (deletionsByWorkflow.size > 0) {
              const topWorkflows = Array.from(deletionsByWorkflow.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
              
              summary.addHeading('üìã Top 10 Workflows by Deletions', 3)
                .addTable([
                  [{data: 'Workflow', header: true}, {data: 'Runs Deleted', header: true}],
                  ...topWorkflows.map(([name, count]) => [name, count.toString()])
                ]);
            }
            
            await summary.write();

  final-report:
    name: üìä Final Report
    runs-on: ubuntu-latest
    needs: [analyze, cleanup-caches, cleanup-runs]
    if: always()
    
    steps:
      - name: üìà Generate Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const cleanupType = '${{ inputs.cleanup_type }}';
            
            // ‚úÖ UPDATED: Tolerant v3 regex
            const V4_PATTERN = /^ccache-suki-v4-([^-]+)-([^-]+)-([^-]+)-([^-]+)-([^-]+)$/;
            const V3_PATTERN = /^ccache-(?:suki-)?v3-([^-]+)-([0-9.]+)-(?:[A-Za-z0-9.-]+-)?(?:clang-[A-Za-z0-9.-]+-)?([A-Za-z0-9._-]+)(?:-.+)?$/;
            
            // ‚úÖ NEW: Safe number formatting helpers
            const toGB = bytes => bytes / 1024 / 1024 / 1024;
            const fmtGB = (bytes, countHint = 0) => {
              if (bytes === 0 && countHint > 0) return '0.00';
              const g = toGB(bytes);
              return g > 0 && g < 0.01 ? '<0.01' : g.toFixed(2);
            };
            const pct = (part, total) => total > 0 ? ((part / total) * 100).toFixed(1) + '%' : '0.0%';
            
            async function withRetry(fn, maxRetries = 3) {
              for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                  return await fn();
                } catch (error) {
                  const isRateLimit = 
                    error.status === 429 || 
                    error.status === 403 ||
                    error.message?.toLowerCase().includes('rate limit') ||
                    error.message?.toLowerCase().includes('secondary rate limit');
                  
                  if (isRateLimit && attempt < maxRetries - 1) {
                    const backoff = 1000 * Math.pow(2, attempt) + Math.floor(Math.random() * 500);
                    console.log(`‚è≥ Rate limit hit, retrying in ${backoff}ms (attempt ${attempt + 1}/${maxRetries})...`);
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    continue;
                  }
                  throw error;
                }
              }
            }
            
            console.log('üìä Generating final report...\n');
            
            // ‚úÖ UPDATED: Parse beforeSize as number (it's already in GB from analyze job)
            const beforeSize = parseFloat('${{ needs.analyze.outputs.total_size }}') || 0;
            const beforeCount = parseInt('${{ needs.analyze.outputs.total_count }}') || 0;
            
            let totalCacheSize = 0;
            let cacheCount = 0;
            const buildFrequency = new Map();
            const recentCutoff = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            
            const caches = await github.paginate(
              github.rest.actions.getActionsCacheList,
              {
                owner,
                repo,
                per_page: 100
              }
            );
            
            for (const cache of caches) {
              totalCacheSize += cache.size_in_bytes;
              cacheCount++;
              
              if (cache.key.startsWith('ccache-')) {
                const isV4Format = cache.key.startsWith('ccache-suki-v4-');
                const isV3Format = cache.key.startsWith('ccache-v3-') || cache.key.startsWith('ccache-suki-v3-');
                
                let device = null;
                
                // ‚úÖ UPDATED: Parse device from cache key with tolerant v3 regex
                if (isV4Format) {
                  const v4Match = cache.key.match(V4_PATTERN);
                  if (v4Match) {
                    device = v4Match[1]; // OP13
                  }
                } else if (isV3Format) {
                  const v3Match = cache.key.match(V3_PATTERN);
                  if (v3Match) {
                    device = v3Match[3]; // OP-ACE-5 or OP-ACE-3V
                  }
                } else {
                  // Legacy format
                  const legacy1 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-clang-[^-]+-([^-]+)$/);
                  const legacy2 = cache.key.match(/^ccache-[^-]+-[\d.]+-[^-]+-([^-]+)$/);
                  device = legacy1?.[1] || legacy2?.[1] || null;
                }
                
                if (device) {
                  const lastAccessDate = new Date(cache.last_accessed_at || cache.created_at);
                  if (lastAccessDate >= recentCutoff) {
                    if (!buildFrequency.has(device)) {
                      buildFrequency.set(device, 0);
                    }
                    buildFrequency.set(device, buildFrequency.get(device) + 1);
                  }
                }
              }
            }
            
            // ‚úÖ UPDATED: Safe calculations
            const afterSizeGBNum = toGB(totalCacheSize);
            const afterSizeGB = fmtGB(totalCacheSize, cacheCount);
            const maxCacheSize = 10 * 1024 * 1024 * 1024;
            const afterPercentNum = totalCacheSize > 0 ? (totalCacheSize / maxCacheSize) * 100 : 0;
            const afterPercent = afterPercentNum.toFixed(1);
            
            const freedSpace = beforeSize - afterSizeGBNum;
            const freedCaches = beforeCount - cacheCount;
            const beforeUsage = beforeSize > 0 ? ((beforeSize / 10) * 100).toFixed(1) : '0.0';
            
            let healthEmoji = 'üü¢';
            let healthStatus = 'Healthy';
            if (afterPercentNum > 90) {
              healthEmoji = 'üî¥';
              healthStatus = 'Critical';
            } else if (afterPercentNum > 75) {
              healthEmoji = 'üü°';
              healthStatus = 'Warning';
            }
            
            const summary = core.summary
              .addHeading(`${healthEmoji} Final Cleanup Report`, 2)
              .addRaw(`\n**Report Date:** ${new Date().toISOString()}\n\n`);
            
            if (dryRun) {
              summary.addRaw(`> ‚ö†Ô∏è **DRY RUN MODE** - This is a simulation. No actual changes were made.\n\n`);
            }
            
            // ‚úÖ UPDATED: Use safe formatting and calculations
            summary.addHeading('üìä Before vs After', 3)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Before', header: true}, {data: 'After', header: true}, {data: 'Change', header: true}],
                ['Cache Size', 
                 `${beforeSize.toFixed(2)} GB`, 
                 `${afterSizeGB} GB`, 
                 dryRun ? `Would free ${freedSpace.toFixed(2)} GB` : `Freed ${freedSpace.toFixed(2)} GB`],
                ['Cache Count', 
                 beforeCount.toString(), 
                 cacheCount.toString(), 
                 dryRun ? `Would delete ${freedCaches}` : `Deleted ${freedCaches}`],
                ['Usage %', 
                 `${beforeUsage}%`, 
                 `${afterPercent}%`, 
                 `${(parseFloat(beforeUsage) - parseFloat(afterPercent)).toFixed(1)}% reduction`],
                ['Health', 
                 '', 
                 healthStatus, 
                 healthEmoji]
              ]);
            
            if (cleanupType !== 'analyze_only') {
              summary.addHeading('üéØ Cleanup Actions Performed', 3)
                .addTable([
                  [{data: 'Action', header: true}, {data: 'Status', header: true}],
                  ['Cache Cleanup', cleanupType === 'cache_only' || cleanupType === 'full_cleanup' ? '‚úÖ Completed' : '‚è≠Ô∏è Skipped'],
                  ['Workflow Runs Cleanup', cleanupType === 'runs_only' || cleanupType === 'full_cleanup' ? '‚úÖ Completed' : '‚è≠Ô∏è Skipped']
                ]);
            }
            
            if (buildFrequency.size > 0) {
              const topDevices = Array.from(buildFrequency.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
              
              summary.addHeading('üì± Most Active Devices (Last 30 Days)', 3)
                .addTable([
                  [{data: 'Device', header: true}, {data: 'Cache Activity', header: true}],
                  ...topDevices.map(([device, count]) => [device, `${count} recent caches`])
                ]);
            }
            
            summary.addHeading('üí° Recommendations', 3);
            
            if (afterPercentNum > 90) {
              summary.addRaw(`\n‚ö†Ô∏è **Critical**: Cache usage is still very high (${afterPercent}%). Consider more aggressive cleanup.\n\n`);
            } else if (afterPercentNum > 75) {
              summary.addRaw(`\n‚ö†Ô∏è **Warning**: Cache usage is elevated (${afterPercent}%). Monitor closely.\n\n`);
            } else {
              summary.addRaw(`\n‚úÖ **Healthy**: Cache usage is at a good level (${afterPercent}%).\n\n`);
            }
            
            if (dryRun) {
              summary.addRaw(`\n> üí° **Next Steps**: Run this workflow again with **dry_run: false** to apply the changes.\n\n`);
            }
            
            await summary.write();
            
            console.log('\n‚úÖ Final report generated successfully'); 
